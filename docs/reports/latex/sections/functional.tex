% ============================================================================
% PART I: FUNCTIONAL SPECIFICATIONS
% ============================================================================

\chapter{Functional Specifications}

\section{Project Information}

\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|l|X|}
        \hline
        \rowcolor{lightgray}
        \textbf{Property} & \textbf{Value} \\
        \hline
        Project name & Ora \\
        \hline
        Team members & Louis Grignola, Amaury Allemand \\
        \hline
        GitHub Frontend & \url{https://github.com/grignolalouis/Ora-mobile/} \\
        \hline
    \end{tabularx}
    \caption{General project information}
    \label{tab:project-info}
\end{table}

% ----------------------------------------------------------------------------
\section{Project Description}

\subsection{Context}

Ora is a platform designed for interacting with conversational AI agents. The project is composed of two distinct components: a mobile frontend developed as a native Android application in Kotlin, which is the subject of this report, and a backend \gls{api} built in Go following a hexagonal architecture pattern.

The mobile application serves as the primary interface for end users to communicate with various AI agents. It provides a seamless chat experience with real-time response streaming, enabling natural and fluid conversations with artificial intelligence systems.

\subsection{Vision}

The primary objective of Ora is to provide a maintainable and scalable boilerplate for building AI agent interaction systems. The platform has been architected with several key principles in mind.

First, the system is designed to be \textbf{agnostic}, meaning it can work with different types of agents including \gls{llm}s, specialized assistants, and custom AI implementations. Each agent operates within its own isolated scope without interfering with others, ensuring a \textbf{modular} architecture that promotes clean separation of concerns.

The platform offers \textbf{flexibility} in agent definition, allowing developers to create agents ranging from simple rule-based systems to complex multi-step reasoning engines. Finally, the entire architecture has been designed with \textbf{scalability} in mind, enabling the system to evolve according to business requirements without requiring fundamental restructuring.

\subsection{Target Audience}

The Ora platform addresses the needs of multiple user segments. Software developers seeking to integrate AI agents into their applications will find Ora provides a robust foundation with well-defined patterns and abstractions. Organizations looking for a customizable AI chat solution can leverage the platform's extensible architecture to build tailored experiences. End users benefit from an intuitive interface that makes interacting with virtual assistants both accessible and enjoyable.

\subsection{Main Features}

The application delivers a comprehensive set of features designed to provide a complete AI chat experience. The authentication system supports user registration, login, and session management through \gls{jwt} tokens, ensuring secure access to the platform.

Users can browse a catalog of available agents, each with its own description and capabilities. The real-time chat functionality implements \gls{sse} \gls{streaming}, allowing responses to appear progressively as they are generated by the AI agent.

Conversation history is persisted per agent, enabling users to continue previous discussions or review past interactions. The user profile section provides account management capabilities including profile picture customization and preference settings. The application supports both light and dark themes, with the interface available in three languages: English, French, and Spanish.

\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|l|X|}
        \hline
        \rowcolor{lightgray}
        \textbf{Feature} & \textbf{Description} \\
        \hline
        Authentication & Registration, login, session management with \gls{jwt} \\
        \hline
        Agent catalog & List of available agents with descriptions \\
        \hline
        Real-time chat & Conversation with \gls{sse} \gls{streaming} responses \\
        \hline
        History & Conversation persistence by agent \\
        \hline
        User profile & Account management, profile picture, preferences \\
        \hline
        Theme & Light/dark mode support \\
        \hline
        Multilingual & Interface in 3 languages (EN, FR, ES) \\
        \hline
    \end{tabularx}
    \caption{Main application features}
    \label{tab:features}
\end{table}

% ----------------------------------------------------------------------------
\section{Global Architecture}

The Ora system follows a client-server architecture where the mobile frontend communicates with a Go backend through HTTPS requests and \gls{sse} connections for real-time streaming.

The backend implements a hexagonal architecture using the tRPC Agent framework, which allows for clean separation between the domain logic and external adapters. Multiple agents can be deployed within the backend, each operating independently with its own configuration and capabilities.

The persistence layer consists of PostgreSQL for relational data storage, Redis for caching and session management, and Minio for file storage including user profile pictures. Phoenix is used for distributed tracing and observability, providing insights into system performance and behavior.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=1.5cm,
        box/.style={rectangle, draw, fill=lightgray, minimum width=4cm, minimum height=1cm, align=center},
        purplebox/.style={rectangle, draw=kotlinpurple, fill=kotlinpurple!10, minimum width=4cm, minimum height=1cm, align=center},
        smallbox/.style={rectangle, draw, fill=white, minimum width=1.8cm, minimum height=0.8cm, align=center, font=\small},
        arrow/.style={->, thick, >=stealth}
    ]

        % Frontend
        \node[purplebox, minimum width=12cm] (frontend) {Mobile Frontend (Kotlin + Jetpack Compose)};

        % Backend
        \node[purplebox, minimum width=12cm, below=of frontend] (backend) {Go Backend (Hexagonal Architecture - tRPC Agent)};

        % Agents inside backend
        \node[smallbox, below=0.5cm of backend.south west, xshift=1.5cm] (agent1) {Agent 1};
        \node[smallbox, right=0.3cm of agent1] (agent2) {Agent 2};
        \node[smallbox, right=0.3cm of agent2] (agent3) {Agent 3};
        \node[smallbox, right=0.3cm of agent3] (agentn) {Agent N};

        % Databases
        \node[box, below=2.5cm of backend, xshift=-4cm] (postgres) {PostgreSQL\\(Data)};
        \node[box, below=2.5cm of backend] (redis) {Redis\\(Cache)};
        \node[box, below=2.5cm of backend, xshift=4cm] (minio) {Minio\\(Files)};

        % Phoenix
        \node[box, below=of redis] (phoenix) {Phoenix\\(Traces)};

        % Arrows
        \draw[arrow] (frontend) -- node[right] {HTTPS / SSE} (backend);
        \draw[arrow] (backend) -- (postgres);
        \draw[arrow] (backend) -- (redis);
        \draw[arrow] (backend) -- (minio);
        \draw[arrow] (redis) -- (phoenix);

    \end{tikzpicture}
    \caption{Ora system global architecture}
    \label{fig:architecture}
\end{figure}

% ----------------------------------------------------------------------------
\section{Use Case Diagram}

The use case diagram illustrates the main interactions between users and the Ora application. Users must first authenticate before accessing the core features of the platform. Once authenticated, they can browse available agents, select one to interact with, and engage in conversations.

The chat functionality encompasses sending messages, viewing \gls{streaming} responses in real-time, accessing conversation history, and managing sessions. Profile management allows users to customize their experience through avatar uploads, theme selection, and language preferences.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{usecase.png}
    \caption{Use case diagram showing user interactions with the Ora platform}
    \label{fig:usecase}
\end{figure}

% ----------------------------------------------------------------------------
\section{Class Diagram}

The complete class diagram contains over 100 classes spanning all architectural layers. Due to its size, a simplified version focusing on core domain entities is presented below.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=0.6cm and 1.8cm,
        class/.style={rectangle, draw=kotlinpurple, fill=kotlinpurple!5, minimum width=3.4cm, align=left, font=\ttfamily\scriptsize},
        classname/.style={rectangle, draw=kotlinpurple, fill=kotlinpurple!20, minimum width=3.4cm, align=center, font=\ttfamily\scriptsize\bfseries},
        enum/.style={rectangle, draw=kotlinpurple!70, fill=kotlinpurple!3, minimum width=2.4cm, align=left, font=\ttfamily\scriptsize},
        enumname/.style={rectangle, draw=kotlinpurple!70, fill=kotlinpurple!15, minimum width=2.4cm, align=center, font=\ttfamily\scriptsize\bfseries},
        relation/.style={->, thick, >=stealth}
    ]
        % User
        \node[classname] (username) {User};
        \node[class, below=0cm of username] (user) {
            +id: String\\
            +name: String\\
            +email: String\\
            +role: String\\
            +verifiedEmail: Boolean\\
            +profilePictureUrl: String?
        };

        % Agent
        \node[classname, right=2.2cm of username] (agentname) {Agent};
        \node[class, below=0cm of agentname] (agent) {
            +type: String\\
            +name: String\\
            +description: String\\
            +greeting: String?\\
            +version: String\\
            +capabilities: List<String>\\
            +icon: String
        };

        % Session
        \node[classname, below=1.2cm of user] (sessionname) {Session};
        \node[class, below=0cm of sessionname] (session) {
            +id: String\\
            +userId: String\\
            +agentType: String\\
            +title: String?\\
            +createdAt: String\\
            +updatedAt: String\\
            +messageCount: Int
        };

        % Message
        \node[classname, right=2.2cm of sessionname] (msgname) {Message};
        \node[class, below=0cm of msgname] (msg) {
            +role: String\\
            +content: String\\
            +timestamp: String\\
            +toolCalls: List?\\
            +toolId: String?\\
            +toolName: String?
        };

        % Interaction
        \node[classname, below=1.2cm of session] (intname) {Interaction};
        \node[class, below=0cm of intname] (int) {
            +id: String\\
            +userMessage: String\\
            +assistantResponse: String\\
            +assistantReasoning: String?\\
            +status: InteractionStatus\\
            +feedbackState: FeedbackState\\
            +toolCalls: List<ToolCall>
        };

        % ToolCall
        \node[classname, right=2.2cm of intname] (toolname) {ToolCall};
        \node[class, below=0cm of toolname] (tool) {
            +id: String\\
            +name: String\\
            +arguments: Map<String, Any>\\
            +status: ToolStatus\\
            +result: String?\\
            +error: String?
        };

        % Enums on the right
        \node[enumname, right=1.8cm of agentname] (isname) {<<enum>>\\InteractionStatus};
        \node[enum, below=0cm of isname] (is) {
            PENDING\\
            THINKING\\
            STREAMING\\
            COMPLETED\\
            ERROR
        };

        \node[enumname, below=0.4cm of is] (tsname) {<<enum>>\\ToolStatus};
        \node[enum, below=0cm of tsname] (ts) {
            PENDING\\
            RUNNING\\
            SUCCESS\\
            ERROR
        };

        % Relations
        \draw[relation] (user.south) -- ++(0,-0.2) -| node[pos=0.25, above, font=\tiny] {1} node[pos=0.75, above, font=\tiny] {*} (session.north);
        \draw[relation] (agent.south) -- ++(0,-0.2) -| node[pos=0.25, above, font=\tiny] {1} node[pos=0.75, above, font=\tiny] {*} ([xshift=0.3cm]session.north);
        \draw[relation] (session.east) -- node[above, font=\tiny] {1..*} (msg.west);
        \draw[relation] (int.east) -- node[above, font=\tiny] {0..*} (tool.west);

    \end{tikzpicture}
    \caption{Simplified class diagram -- Domain entities}
    \label{fig:classdiagram}
\end{figure}

The domain layer defines the fundamental entities: \texttt{User} represents authenticated users, \texttt{Agent} encapsulates AI agent metadata, \texttt{Session} tracks conversation instances, and \texttt{Message} stores chat messages with optional tool call information.

The \texttt{Interaction} class represents a complete exchange between user and assistant, including any intermediate tool calls. Repository interfaces (\texttt{AuthRepository}, \texttt{AgentRepository}, \texttt{SessionRepository}) define data access contracts following the dependency inversion principle.

The presentation layer implements \gls{mvi} through dedicated ViewModels: \texttt{AuthViewModel}, \texttt{ChatViewModel}, and \texttt{UserProfileViewModel}.

% ----------------------------------------------------------------------------
\section{Screenshots}

\subsection{Authentication}

The authentication screens provide a clean and intuitive interface for user onboarding. The login screen presents email and password fields with the Ora logo prominently displayed, while the registration screen includes additional fields for username and password confirmation. Both screens implement real-time validation, providing immediate feedback when users enter invalid data.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{login.png}
        \caption{Login screen}
        \label{fig:login}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{signup.png}
        \caption{Registration screen}
        \label{fig:signup}
    \end{subfigure}
    \caption{Authentication screens with real-time field validation}
    \label{fig:auth-screens}
\end{figure}

\subsection{Home Page and Navigation}

The home screen displays the agent catalog as a collection of cards, each showing the agent's name, description, and icon. Users can browse available agents and select one to begin a conversation. The sidebar navigation drawer provides access to conversation history and allows users to quickly switch between previous sessions or navigate to profile settings.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{home.png}
        \caption{Agent catalog}
        \label{fig:home}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{sidebar.png}
        \caption{Side menu (drawer)}
        \label{fig:sidebar}
    \end{subfigure}
    \caption{Main application navigation}
    \label{fig:nav-screens}
\end{figure}

\subsection{Chat Interface}

The chat interface is the core feature of the Ora application. The message input area at the bottom of the screen provides a text field with a send button, optimized for quick and intuitive message composition. User messages appear on the right side of the conversation view, while agent responses are displayed on the left.

The application supports full Markdown rendering including syntax highlighting for code blocks. This is particularly important for technical agents that may provide code examples or technical documentation in their responses.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{input.png}
        \caption{Message input area}
        \label{fig:input}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{chat.png}
        \caption{Conversation with agent}
        \label{fig:chat}
    \end{subfigure}
    \caption{Chat interface with Markdown rendering and syntax highlighting}
    \label{fig:chat-screens}
\end{figure}

During request processing, the application displays a thinking indicator that informs users the agent is analyzing their message. This visual feedback is essential for maintaining a responsive feel even when complex reasoning operations are being performed on the backend.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{reflexion.png}
    \caption{Thinking indicator during request processing}
    \label{fig:reflexion}
\end{figure}

\subsection{Tool Calls}

One of the distinguishing features of Ora is its support for agent tool calls. When an agent needs to perform actions such as searching for information, executing code, or accessing external services, these operations are displayed transparently to the user.

The tool call interface shows which tools are being invoked along with their parameters, allowing users to understand exactly what actions the agent is taking on their behalf. Once tool execution completes, the results are integrated into the conversation flow alongside the agent's final response.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{tools.png}
        \caption{Tool execution}
        \label{fig:tools}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{tools+answer.png}
        \caption{Result with response}
        \label{fig:tools-answer}
    \end{subfigure}
    \caption{Display of tool calls made by the agent}
    \label{fig:tools-screens}
\end{figure}

\subsection{User Profile}

The user profile screen centralizes all account management and preference settings. Users can view and edit their personal information, upload a custom profile picture, and customize the application experience through theme and language selection. Account actions including logout and account deletion are also accessible from this screen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{user.png}
    \caption{Profile page with settings (theme, language, account)}
    \label{fig:user}
\end{figure}

% ----------------------------------------------------------------------------
\section{Technical Challenges Overcome}

The development of Ora presented several significant technical challenges that required careful consideration and innovative solutions. These challenges primarily arose from the need to provide a seamless real-time chat experience while maintaining clean architecture principles.

\subsection{Real-time SSE Streaming}

The most complex challenge involved implementing \gls{sse} \gls{streaming} for AI responses. Unlike traditional HTTP requests that return complete responses, \gls{sse} requires maintaining a persistent connection and processing data as it arrives token by token.

The Android lifecycle adds additional complexity, as connections must survive configuration changes like screen rotations while being properly cleaned up when the activity is destroyed. Events arrive on IO threads and must be dispatched to the main thread for UI updates without blocking the interface during rapid event bursts.

The solution implements a buffering mechanism with implicit debouncing, combined with Kotlin \gls{flow} operators like \texttt{conflate()} to handle backpressure when events arrive faster than the UI can process them.

\subsection{Custom Markdown Rendering}

Jetpack Compose does not provide a native Markdown component, requiring a hybrid approach using the Markwon library within an \texttt{AndroidView}. This creates interoperability challenges between the Compose theming system and traditional Android Views.

Syntax highlighting for code blocks across 13 programming languages was implemented through a custom \texttt{SyntaxHighlighter} with regex-based parsing. To address performance concerns with large code blocks, the solution employs lazy parsing and an LRU cache to memoize results.

\subsection{MVI Architecture with Streaming State}

The standard \gls{mvi} pattern assumes discrete states with atomic transitions, but \gls{streaming} introduces a continuously evolving state that updates multiple times per second. The solution uses composite states with independent sub-states, allowing the streaming content to be updated without triggering unnecessary recomposition of unrelated UI elements.

\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|l|c|X|}
        \hline
        \rowcolor{lightgray}
        \textbf{Challenge} & \textbf{Complexity} & \textbf{Solution} \\
        \hline
        Real-time \gls{sse} \gls{streaming} & High & Buffering with debounce, StateFlow with conflate \\
        \hline
        Custom Markdown rendering & High & Markwon + custom SyntaxHighlighter with LRU cache \\
        \hline
        \gls{mvi} architecture streaming & Medium & Composite states with independent sub-states \\
        \hline
        Auth with refresh token & Medium & AuthInterceptor with Mutex to avoid race conditions \\
        \hline
        OkHttp/Ktor integration & Medium & Shared Hilt module, common factory \\
        \hline
    \end{tabularx}
    \caption{Summary of major technical challenges}
    \label{tab:challenges}
\end{table}

